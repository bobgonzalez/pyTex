S Refactoring
\textbf{Refactoring} changes the software structure but does not change the functionality of the program.
BL
IT Important activity during evolution
EL
Refactoring consists of behaviour preserving transformations.
SS Two Roles of Refactoring
BLN
IT Opportunistic refactoring
BL
IT (pre-factoring)‫‏‬
IT Before attempting the actualization
BL
IT Refactoring will make actualization easier
EL
EL
IT Improving the architecture
BL
IT (post-factoring)‫‏‬
IT Prepares software for future evolution
IT Driven by aesthetics, not specific need
EL
ELN
SS Extract Function
Extracting part of the function into another
function will make it:
BL
IT easier to understand
IT reusable
EL
SS Extract Function Process
BLN
IT Select a block of code for extraction
IT Is the block syntactically complete?
IT Create new function
IT Extract the selected block as a function body
IT Replace the code block with the function call
ELN
SS Variables during Extract Function
BL
IT Local variable
BL
IT Value assigned inside, used only inside
EL
IT Parameter passed by value
BL
IT Value assigned outside and used inside
EL
IT Parameter passed by reference
BL
IT Value assigned and used outside, changed inside and visible outside
EL
IT Global variable
EL
SS Extract a Base Class
BL
IT In the design process, derived classes often come before the base classes
BL
IT Designers may miss some base classes
IT Refactoring base class will correct these omissions
EL
IT Extract a base class prepares software for incorporation of new functionality through polymorphism
BL
IT Applicable when old and new functionality have a large overlap
EL
EL
SS Component Class Extraction
BL
IT Motivation: incorporation by replacemen
BL
IT Primitive implementation of the class is replaced by a full functionality
EL
IT Concept sometimes does not have class of its own
BL
IT Must be extracted from another class
IT Prefactoring for incorporation by replacement
EL
EL
SS Signs you should Refactor
BL
IT code is B{duplicated}
IT a routine is B{too long}
IT a loop is too long or B{deeply nested}
IT a class has poor B{cohesion}
IT a class uses too much B{coupling}
IT too many B{parameters}
IT to B{compartmentalize} changes (change one place → must change others)
IT to B{group related data} into a class
IT a B{"middle man"} object doesn't do much
IT B{poor encapsulation} of data that should be private
IT a B{weak subclass} doesn't use its inherited functionality
IT a class contains B{unused code}
EL
SS Other Types of Refactoring
BL
IT refactoring to fit B{design patterns}
IT B{splitting} one method into several to improve cohesion and readability
IT changing method B{signatures}
IT performance B{optimization}
IT B{moving} statements that semantically belong together near each other
IT naming (extracting) "magic" B{constants}
IT B{exchanging idioms} that are risky with safer alternatives
IT B{clarifying} a statement that has evolved over time or is unclear
EL
SS Refactoring Plan
BL
IT Analyze the code to decide the risks and benefits of refactoring.
BL
IT If it is too risky, not enough time remains, or the refactoring will not produce enough benefit to the project, don't do it.
EL
IT Save / backup / check-in the code before you mess with it.
IT Write unit tests that verify the code's external correctness.
BL
IT They should pass on the current poorly designed code.
IT Having unit tests helps make sure any refactor doesn't break existing behavior (regressions).
EL
IT Refactor the code.
BL
IT Some unit tests may break. Fix the bugs.
IT Perform functional/integration/regression testing. Fix any issues.
EL
IT Code review the changes.
IT Check-in your refactored code.
BL
IT Keep each refactoring small; refactor one issue / unit at a time.
BL
IT Helps isolate new bugs and regressions
EL
IT Your check-in should contain only the refactored code.
BL
IT NOT other changes such as adding features, fixing unrelated bugs.
IT Do those in a separate check-in (resist temptation to fix small bugs or other tweaks; this is dangerous)
EL
EL
EL
SS Dangers of Refactoring
BL
IT Code that used to be ...
BL
IT Well commented, now (maybe) isn't
IT Fully tested, now (maybe) isn't
IT Fully reviewed, now (maybe) isn't
EL
IT Easy to insert a bug into previously working code ( B{regression} )
EL
SS Phased Refactoring
Adding a B{layer of abstraction} on top of legacy code.
BL
IT New well-made System 2 on top of poorly made old System 1.
IT System 1 remains; Direct access to it is deprecated.
IT For now, System 2 still forwards some calls down to System 1 to achieve feature parity.
IT Over time, calls to System 1 code are replaced by new System 2 code providing the same functionality with a better design.
EL
